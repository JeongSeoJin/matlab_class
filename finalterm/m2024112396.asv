%%
clear; clc; close all;
fprintf("[Prob 1]\n");

% [Prob 1-(1)]
func = @(x) x.^0.3 .* cosh(x).^2;
result = integral(func, 0, 1)

% [Prob 1-(2)]
f = [1 0 2 -3];
a = polyval(polyder(f), -3)

% [Prob 1-(3)]
fx = @(x) cosh(x)./exp(x) - 2.5 * sin(x) - (0.08 * x.^2 - x - 0.15);
fplot(fx, [-1, 15]);
grid on;

x1 = fzero(fx, 0.5)
x2 = fzero(fx, 2)
x3 = fzero(fx, 12)

%%
dydt = @(t, y)(y+sin(t)); % dydt만 남기고 나머지를 우변으로 넘겨줌.
[t1, y1] = ode45(dydt, 0:0.314:3.14, 10)
% 'ro'로 표현된 함수가 위의 식을 만족함. 

%(2) analytical solution = 진짜 정답

hold on
plot(t1, y1, 'o')
%%
% [Prob 1-(4)]
dydt = @(t, y) (t + cos(t)) / (y + 1);  % 미분방정식 정의
[t, y] = ode45(dydt, 0:0.01:2.5, -1);

hold on
% % 그래프를 그리기
figure(2);
plot(t, y); 
 
%% 
clear; clc; close all;
fprintf("[Prob 2]\n");
% [Prob 2-(a)]

% (1) 점 P의 좌표 (x, y) 선언
a = 2;
theta = linspace(0, 10*pi, 1000);
x = @(theta) a * (theta - sin(theta));
y = @(theta) a * (1 - cos(theta));

% (2) 주어진 범위에서 점 P의 자취 그리기
figure;
plot(x(theta), y(theta)); % 파란색으로 점 P의 자취를 그리기
axis equal;
hold on;


% (3) 점 Q의 좌표 (x_c, y_c) 선언
f = @(t) t.^2;  % 함수 f(t) = t^2
xc = @(theta, t) a * cos(theta) + a * f(t); 
yc = @(theta, t) a * sin(theta) + a;

% (4) 
t_vals = 0:1:5;
for i = 1:length(t_vals)
    t = t_vals(i);
    plot(xc(theta, t), yc(theta, t)); 
    hold on;
end

grid on;

%%
clear; clc; close all;
fprintf("[Prob 3]\n");

% 시간 변수 설정
t = 1.5:0.1:3.2;

% 이론 값 y_true(t) 정의 (익명 함수)
y_true = @(t) 4 * (t .^ (3/2));

% 노이즈 함수 y_noise(t) 정의 (익명 함수)
y_noise = @(t) 10 * (rand(1) - 0.5);  % 매번 다른 노이즈 생성

% 측정된 값 계산을 위한 초기화
y_measured_vals = zeros(size(t));

% 각 시간에 대해 측정된 값 계산 (for문을 이용해 노이즈 추가)
for i = 1:length(t)
    y_measured_vals(i) = y_true(t(i)) + y_noise(t(i));
end

% 이론 값 계산
y_true_vals = y_true(t);

% 그래프 그리기
figure;
plot(t, y_true_vals);
hold on;
plot(t, y_measured_vals, '-');
xlabel('Time (s)');
ylabel('y(t)');
title('True Value and Measured Value with Noise');
legend;
grid on;

% 피팅
% 1차 다항식 피팅
p1 = polyfit(t, y_measured_vals, 1);
y_fit1 = polyval(p1, t);

% 2차 다항식 피팅
p2 = polyfit(t, y_measured_vals, 2);
y_fit2 = polyval(p2, t);

% 3차 다항식 피팅
p3 = polyfit(t, y_measured_vals, 3);
y_fit3 = polyval(p3, t);

% 피팅 결과 그래프에 추가
subplot(2,2,1)
plot(t, y_fit1, '--g', 'DisplayName', '1st Order Fit');
subplot(2,2,2)
plot(t, y_fit2, '--m', 'DisplayName', '2nd Order Fit');
subplot(2,2,3)
plot(t, y_fit3, '--k', 'DisplayName', '3rd Order Fit');
legend;

% 오차 계산
error1 = norm(y_true_vals - y_fit1);
error2 = norm(y_true_vals - y_fit2);
error3 = norm(y_true_vals - y_fit3);

% 결과 출력
fprintf('Error for 1st Order Fit: %.4f\n', error1);
fprintf('Error for 2nd Order Fit: %.4f\n', error2);
fprintf('Error for 3rd Order Fit: %.4f\n', error3);

% 최적의 피팅 차수 찾기
[~, best_fit_order] = min([error1, error2, error3]);
fprintf('Best fit is %dth order polynomial with error: %.4f\n', best_fit_order, min([error1, error2, error3]));
